// Tests for A.7.4 — Specify path delays

#include <gtest/gtest.h>

#include <string>

#include "common/arena.h"
#include "common/diagnostic.h"
#include "common/source_mgr.h"
#include "lexer/lexer.h"
#include "parser/ast.h"
#include "parser/parser.h"

using namespace delta;

namespace {

struct ParseResult {
  SourceManager mgr;
  Arena arena;
  CompilationUnit* cu = nullptr;
  bool has_errors = false;
};

ParseResult Parse(const std::string& src) {
  ParseResult result;
  auto fid = result.mgr.AddFile("<test>", src);
  DiagEngine diag(result.mgr);
  Lexer lexer(result.mgr.FileContent(fid), fid, diag);
  Parser parser(lexer, result.arena, diag);
  result.cu = parser.Parse();
  result.has_errors = diag.HasErrors();
  return result;
}

ModuleItem* FindSpecifyBlock(const std::vector<ModuleItem*>& items) {
  for (auto* item : items) {
    if (item->kind == ModuleItemKind::kSpecifyBlock) return item;
  }
  return nullptr;
}

SpecifyItem* GetSolePathItem(ParseResult& r) {
  if (!r.cu || r.cu->modules.empty()) return nullptr;
  auto* spec = FindSpecifyBlock(r.cu->modules[0]->items);
  if (!spec || spec->specify_items.empty()) return nullptr;
  return spec->specify_items[0];
}

}  // namespace

// =============================================================================
// A.7.4 path_delay_value — bare vs parenthesized
// =============================================================================

// path_delay_value ::= list_of_path_delay_expressions (bare form)
TEST(ParserA704, PathDelayValueBare) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = 5;\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 1u);
}

// path_delay_value ::= ( list_of_path_delay_expressions ) (parenthesized)
TEST(ParserA704, PathDelayValueParenthesized) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (5);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 1u);
}

// =============================================================================
// A.7.4 list_of_path_delay_expressions — 1, 2, 3, 6, 12 delays
// =============================================================================

// 1 delay: t_path_delay_expression
TEST(ParserA704, ListOfPathDelayExpr1) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = 10;\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 1u);
}

// 2 delays: trise, tfall
TEST(ParserA704, ListOfPathDelayExpr2) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (3, 5);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 2u);
}

// 3 delays: trise, tfall, tz
TEST(ParserA704, ListOfPathDelayExpr3) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (2, 3, 4);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 3u);
}

// 6 delays: t01, t10, t0z, tz1, t1z, tz0
TEST(ParserA704, ListOfPathDelayExpr6) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a *> b) = (1, 2, 3, 4, 5, 6);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 6u);
}

// 12 delays: t01, t10, t0z, tz1, t1z, tz0, t0x, tx1, t1x, tx0, txz, tzx
TEST(ParserA704, ListOfPathDelayExpr12) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a *> b) = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 12u);
}

// =============================================================================
// A.7.4 path_delay_expression ::= constant_mintypmax_expression
// =============================================================================

// Single min:typ:max delay (bare form)
TEST(ParserA704, PathDelayExprMinTypMaxBare) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = 1:2:3;\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 1u);
  EXPECT_EQ(si->path.delays[0]->kind, ExprKind::kMinTypMax);
}

// Single min:typ:max delay (parenthesized)
TEST(ParserA704, PathDelayExprMinTypMaxParenthesized) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (1:2:3);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 1u);
  EXPECT_EQ(si->path.delays[0]->kind, ExprKind::kMinTypMax);
}

// 2 delays with min:typ:max (trise, tfall)
TEST(ParserA704, PathDelayExprMinTypMax2) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (1:2:3, 4:5:6);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 2u);
  EXPECT_EQ(si->path.delays[0]->kind, ExprKind::kMinTypMax);
  EXPECT_EQ(si->path.delays[1]->kind, ExprKind::kMinTypMax);
}

// 3 delays with min:typ:max (trise, tfall, tz)
TEST(ParserA704, PathDelayExprMinTypMax3) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (1:2:3, 4:5:6, 7:8:9);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 3u);
  for (int i = 0; i < 3; ++i) {
    EXPECT_EQ(si->path.delays[i]->kind, ExprKind::kMinTypMax);
  }
}

// 6 delays with min:typ:max
TEST(ParserA704, PathDelayExprMinTypMax6) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a *> b) = (1:2:3, 4:5:6, 7:8:9, 10:11:12, 13:14:15, 16:17:18);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 6u);
  for (int i = 0; i < 6; ++i) {
    EXPECT_EQ(si->path.delays[i]->kind, ExprKind::kMinTypMax);
  }
}

// 12 delays with min:typ:max
TEST(ParserA704, PathDelayExprMinTypMax12) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a *> b) = (1:2:3, 4:5:6, 7:8:9, 10:11:12, 13:14:15, 16:17:18,\n"
      "               19:20:21, 22:23:24, 25:26:27, 28:29:30, 31:32:33, "
      "34:35:36);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  ASSERT_EQ(si->path.delays.size(), 12u);
  for (int i = 0; i < 12; ++i) {
    EXPECT_EQ(si->path.delays[i]->kind, ExprKind::kMinTypMax);
  }
}

// =============================================================================
// A.7.4 path_delay_value with specparam reference
// =============================================================================

// Delay using specparam identifier
TEST(ParserA704, PathDelayWithSpecparam) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    specparam tDelay = 10;\n"
      "    (a => b) = tDelay;\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* spec = FindSpecifyBlock(r.cu->modules[0]->items);
  ASSERT_NE(spec, nullptr);
  ASSERT_GE(spec->specify_items.size(), 2u);
  auto* path_item = spec->specify_items[1];
  EXPECT_EQ(path_item->kind, SpecifyItemKind::kPathDecl);
  ASSERT_EQ(path_item->path.delays.size(), 1u);
}

// Rise/fall delays using specparam identifiers
TEST(ParserA704, PathDelayRiseFallSpecparams) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    specparam tRise = 3;\n"
      "    specparam tFall = 5;\n"
      "    (a => b) = (tRise, tFall);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
}

// =============================================================================
// A.7.4 Invalid delay counts (not 1, 2, 3, 6, or 12)
// =============================================================================

// 4 delays — invalid
TEST(ParserA704, InvalidDelayCount4) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (1, 2, 3, 4);\n"
      "  endspecify\n"
      "endmodule\n");
  EXPECT_TRUE(r.has_errors);
}

// 5 delays — invalid
TEST(ParserA704, InvalidDelayCount5) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (1, 2, 3, 4, 5);\n"
      "  endspecify\n"
      "endmodule\n");
  EXPECT_TRUE(r.has_errors);
}

// =============================================================================
// A.7.4 6 and 12 delays on parallel and full paths
// =============================================================================

// 6 delays on a parallel path
TEST(ParserA704, SixDelaysParallelPath) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (1, 2, 3, 4, 5, 6);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  EXPECT_EQ(si->path.path_kind, SpecifyPathKind::kParallel);
  ASSERT_EQ(si->path.delays.size(), 6u);
}

// 12 delays on a parallel path
TEST(ParserA704, TwelveDelaysParallelPath) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (a => b) = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  EXPECT_EQ(si->path.path_kind, SpecifyPathKind::kParallel);
  ASSERT_EQ(si->path.delays.size(), 12u);
}

// 6 delays with edge-sensitive path
TEST(ParserA704, SixDelaysEdgeSensitive) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    (posedge clk => q) = (1, 2, 3, 4, 5, 6);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  EXPECT_EQ(si->path.edge, SpecifyEdge::kPosedge);
  ASSERT_EQ(si->path.delays.size(), 6u);
}

// 6 delays with conditional path
TEST(ParserA704, SixDelaysConditionalPath) {
  auto r = Parse(
      "module m;\n"
      "  specify\n"
      "    if (en) (a => b) = (1, 2, 3, 4, 5, 6);\n"
      "  endspecify\n"
      "endmodule\n");
  ASSERT_NE(r.cu, nullptr);
  EXPECT_FALSE(r.has_errors);
  auto* si = GetSolePathItem(r);
  ASSERT_NE(si, nullptr);
  EXPECT_NE(si->path.condition, nullptr);
  ASSERT_EQ(si->path.delays.size(), 6u);
}
