#include "simulation/vcd_writer.h"

#include <algorithm>
#include <cassert>
#include <set>

namespace delta {

// --- Construction / destruction ---

VcdWriter::VcdWriter(std::string filename, std::string timescale)
    : filename_(std::move(filename)), timescale_(std::move(timescale)) {
    file_.open(filename_, std::ios::out | std::ios::trunc);
}

VcdWriter::~VcdWriter() {
    close();
}

// --- Signal registration ---

void VcdWriter::add_signal(std::string_view scope, std::string_view name, uint32_t width) {
    SignalEntry entry;
    entry.scope = std::string(scope);
    entry.name = std::string(name);
    entry.width = width;
    entry.id = next_id_++;
    signals_.push_back(std::move(entry));
}

// --- Header output ---

void VcdWriter::write_header() {
    if (header_written_ || !file_.is_open()) {
        return;
    }

    file_ << "$date\n  Generated by DeltaHDL\n$end\n";
    file_ << "$version\n  DeltaHDL Simulator\n$end\n";
    file_ << "$timescale\n  " << timescale_ << "\n$end\n";

    write_scope_hierarchy();

    file_ << "$enddefinitions $end\n";
    file_ << "$dumpvars\n";

    // Emit initial X for all signals
    for (const auto& sig : signals_) {
        if (sig.width == 1) {
            file_ << 'x' << make_id_string(sig.id) << '\n';
        } else {
            file_ << 'b';
            for (uint32_t j = 0; j < sig.width; ++j) {
                file_ << 'x';
            }
            file_ << ' ' << make_id_string(sig.id) << '\n';
        }
    }

    file_ << "$end\n";
    header_written_ = true;
}

// --- Timestamp and value change ---

void VcdWriter::write_timestamp(SimTime time) {
    if (!file_.is_open()) {
        return;
    }
    file_ << '#' << time.ticks << '\n';
}

void VcdWriter::write_value_change(uint32_t signal_id, const Logic4Vec& value) {
    if (!file_.is_open()) {
        return;
    }
    assert(signal_id < signals_.size());

    const auto& sig = signals_[signal_id];
    std::string id_str = make_id_string(signal_id);

    if (sig.width == 1) {
        write_scalar_change(value, id_str);
    } else {
        write_vector_change(value, sig.width, id_str);
    }
}

void VcdWriter::close() {
    if (file_.is_open()) {
        file_.flush();
        file_.close();
    }
}

// --- Internal helpers ---

std::string VcdWriter::make_id_string(uint32_t id) {
    // VCD identifiers use printable ASCII starting from '!'
    std::string result;
    uint32_t val = id;
    do {
        result.push_back(static_cast<char>('!' + (val % 94)));
        val /= 94;
    } while (val > 0);
    return result;
}

void VcdWriter::write_scope_hierarchy() {
    // Collect unique scopes
    std::set<std::string> scopes;
    for (const auto& sig : signals_) {
        scopes.insert(sig.scope);
    }

    for (const auto& scope : scopes) {
        file_ << "$scope module " << scope << " $end\n";
        write_signal_defs(scope);
        file_ << "$upscope $end\n";
    }
}

void VcdWriter::write_signal_defs(const std::string& scope) {
    for (const auto& sig : signals_) {
        if (sig.scope != scope) {
            continue;
        }
        file_ << "$var wire " << sig.width << ' ' << make_id_string(sig.id) << ' ' << sig.name
              << " $end\n";
    }
}

// --- Value formatting helpers ---

static char logic4_bit_char(const Logic4Vec& value, uint32_t bit) {
    uint32_t word_idx = bit / 64;
    uint32_t bit_idx = bit % 64;

    if (word_idx >= value.nwords) {
        return 'x';
    }

    uint64_t a = (value.words[word_idx].aval >> bit_idx) & 1;
    uint64_t b = (value.words[word_idx].bval >> bit_idx) & 1;

    if (b == 0 && a == 0)
        return '0';
    if (b == 0 && a == 1)
        return '1';
    if (b == 1 && a == 0)
        return 'x';
    return 'z';
}

void VcdWriter::write_scalar_change(const Logic4Vec& value, const std::string& id_str) {
    char ch = logic4_bit_char(value, 0);
    file_ << ch << id_str << '\n';
}

void VcdWriter::write_vector_change(const Logic4Vec& value, uint32_t width,
                                    const std::string& id_str) {
    file_ << 'b';
    for (int32_t i = static_cast<int32_t>(width) - 1; i >= 0; --i) {
        file_ << logic4_bit_char(value, static_cast<uint32_t>(i));
    }
    file_ << ' ' << id_str << '\n';
}

} // namespace delta
