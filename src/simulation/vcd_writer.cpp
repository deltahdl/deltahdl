#include "simulation/vcd_writer.h"

#include "simulation/variable.h"

namespace delta {

VcdWriter::VcdWriter(const std::string& filename) : ofs_(filename) {}

VcdWriter::~VcdWriter() {
  if (ofs_.is_open()) ofs_.close();
}

void VcdWriter::WriteHeader(std::string_view timescale) {
  if (!ofs_.is_open()) return;
  ofs_ << "$date\n  Generated by DeltaHDL\n$end\n";
  ofs_ << "$version\n  DeltaHDL 0.1.0\n$end\n";
  ofs_ << "$timescale\n  " << timescale << "\n$end\n";
  header_written_ = true;
}

void VcdWriter::BeginScope(std::string_view name) {
  if (!ofs_.is_open()) return;
  ofs_ << "$scope module " << name << " $end\n";
}

void VcdWriter::EndScope() {
  if (!ofs_.is_open()) return;
  ofs_ << "$upscope $end\n";
}

void VcdWriter::RegisterSignal(std::string_view name, uint32_t width,
                               Variable* var) {
  VcdSignal sig;
  sig.name = name;
  sig.width = width;
  sig.var = var;
  sig.ident = next_ident_++;
  // Wrap around VCD printable identifier range.
  if (next_ident_ > '~') next_ident_ = '!';
  signals_.push_back(sig);
  if (ofs_.is_open()) {
    ofs_ << "$var wire " << width << " " << sig.ident << " " << name
         << " $end\n";
  }
}

void VcdWriter::EndDefinitions() {
  if (!ofs_.is_open()) return;
  ofs_ << "$enddefinitions $end\n";
}

void VcdWriter::WriteTimestamp(uint64_t time) {
  if (!ofs_.is_open() || !enabled_) return;
  ofs_ << "#" << time << "\n";
  last_time_ = time;
}

void VcdWriter::WriteScalarChange(const VcdSignal& sig) {
  if (!sig.var) return;
  uint64_t aval = sig.var->value.ToUint64() & 1;
  uint64_t bval = 0;
  if (sig.var->value.nwords > 0) {
    bval = sig.var->value.words[0].bval & 1;
  }
  char val = '0';
  if (!bval && aval) {
    val = '1';
  } else if (bval && !aval) {
    val = 'x';
  } else if (bval && aval) {
    val = 'z';
  }
  ofs_ << val << sig.ident << "\n";
}

void VcdWriter::WriteVectorChange(const VcdSignal& sig) {
  if (!sig.var) return;
  ofs_ << "b";
  for (int32_t i = static_cast<int32_t>(sig.width) - 1; i >= 0; --i) {
    uint32_t word_idx = static_cast<uint32_t>(i) / 64;
    uint32_t bit_idx = static_cast<uint32_t>(i) % 64;
    uint64_t mask = uint64_t{1} << bit_idx;
    bool a = false;
    bool b = false;
    if (word_idx < sig.var->value.nwords) {
      a = (sig.var->value.words[word_idx].aval & mask) != 0;
      b = (sig.var->value.words[word_idx].bval & mask) != 0;
    }
    if (!b && !a) {
      ofs_ << '0';
    } else if (!b && a) {
      ofs_ << '1';
    } else if (b && !a) {
      ofs_ << 'x';
    } else {
      ofs_ << 'z';
    }
  }
  ofs_ << " " << sig.ident << "\n";
}

void VcdWriter::WriteSignalChange(const VcdSignal& sig) {
  if (sig.width == 1) {
    WriteScalarChange(sig);
  } else {
    WriteVectorChange(sig);
  }
}

static bool HasValueChanged(const VcdSignal& sig) {
  for (uint32_t w = 0; w < sig.var->value.nwords; ++w) {
    if (sig.var->value.words[w].aval != sig.var->prev_value.words[w].aval ||
        sig.var->value.words[w].bval != sig.var->prev_value.words[w].bval) {
      return true;
    }
  }
  return false;
}

void VcdWriter::DumpAllValues() {
  if (!ofs_.is_open() || !enabled_) return;
  ofs_ << "$dumpvars\n";
  for (const auto& sig : signals_) {
    WriteSignalChange(sig);
  }
  ofs_ << "$end\n";
}

void VcdWriter::DumpChangedValues(uint64_t /*prev_time*/) {
  if (!ofs_.is_open() || !enabled_) return;
  for (const auto& sig : signals_) {
    if (!sig.var) continue;
    if (!HasValueChanged(sig)) continue;
    WriteSignalChange(sig);
  }
}

}  // namespace delta
